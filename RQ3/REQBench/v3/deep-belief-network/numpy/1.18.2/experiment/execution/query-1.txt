
                        **Debug Mission** 
                        Resolve runtime crash caused by code-level incompatibilities in dependency chain.

                        **Input Context**
                        - Current environment: absl-py==1.4.0
bleach==1.5.0
certifi==2021.5.30
dataclasses==0.8
html5lib==0.9999999
importlib-metadata==4.8.3
Markdown==3.3.7
numpy==1.18.2
protobuf==3.19.6
scikit-learn==0.18.1
scipy==0.18.1
six==1.16.0
tensorflow==1.5.0
tensorflow-tensorboard==1.5.1
typing_extensions==4.1.1
Werkzeug==2.0.3
zipp==3.6.0

                        - Python version: 3.6
                        - Project source code: import numpy as np

np.random.seed(1337)  # for reproducibility
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.metrics.classification import accuracy_score

from dbn.tensorflow import SupervisedDBNClassification


# Loading dataset
digits = load_digits()
X, Y = digits.data, digits.target

# Data scaling
X = (X / 16).astype(np.float32)

# Splitting data
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=0)

# Training
classifier = SupervisedDBNClassification(hidden_layers_structure=[256, 256],
                                         learning_rate_rbm=0.05,
                                         learning_rate=0.1,
                                         n_epochs_rbm=1,
                                         n_iter_backprop=1,
                                         batch_size=32,
                                         activation_function='relu',
                                         dropout_p=0.2)
classifier.fit(X_train, Y_train)

# Test
Y_pred = classifier.predict(X_test)
print('Done.\nAccuracy: %f' % accuracy_score(Y_test, Y_pred))

                        - library source code: """Functions copypasted from newer versions of numpy.

"""
from __future__ import division, print_function, absolute_import

import warnings
import sys

import numpy as np
from numpy.testing.nosetester import import_nose

from scipy._lib._version import NumpyVersion

if NumpyVersion(np.__version__) > '1.7.0.dev':
    _assert_warns = np.testing.assert_warns
else:
    def _assert_warns(warning_class, func, *args, **kw):
        r"""
        Fail unless the given callable throws the specified warning.

        This definition is copypasted from numpy 1.9.0.dev.
        The version in earlier numpy returns None.

        Parameters
        ----------
        warning_class : class
            The class defining the warning that `func` is expected to throw.
        func : callable
            The callable to test.
        *args : Arguments
            Arguments passed to `func`.
        **kwargs : Kwargs
            Keyword arguments passed to `func`.

        Returns
        -------
        The value returned by `func`.

        """
        with warnings.catch_warnings(record=True) as l:
            warnings.simplefilter('always')
            result = func(*args, **kw)
            if not len(l) > 0:
                raise AssertionError("No warning raised when calling %s"
                        % func.__name__)
            if not l[0].category is warning_class:
                raise AssertionError("First warning for %s is not a "
                        "%s( is %s)" % (func.__name__, warning_class, l[0]))
        return result


def assert_raises_regex(exception_class, expected_regexp,
                        callable_obj=None, *args, **kwargs):
    """
    Fail unless an exception of class exception_class and with message that
    matches expected_regexp is thrown by callable when invoked with arguments
    args and keyword arguments kwargs.
    Name of this function adheres to Python 3.2+ reference, but should work in
    all versions down to 2.6.
    Notes
    -----
    .. versionadded:: 1.8.0
    """
    __tracebackhide__ = True  # Hide traceback for py.test
    nose = import_nose()

    if sys.version_info.major >= 3:
        funcname = nose.tools.assert_raises_regex
    else:
        # Only present in Python 2.7, missing from unittest in 2.6
            funcname = nose.tools.assert_raises_regexp

    return funcname(exception_class, expected_regexp, callable_obj,
                    *args, **kwargs)


if NumpyVersion(np.__version__) >= '1.10.0':
    from numpy import broadcast_to
else:
    # Definition of `broadcast_to` from numpy 1.10.0.

    def _maybe_view_as_subclass(original_array, new_array):
        if type(original_array) is not type(new_array):
            # if input was an ndarray subclass and subclasses were OK,
            # then view the result as that subclass.
            new_array = new_array.view(type=type(original_array))
            # Since we have done something akin to a view from original_array, we
            # should let the subclass finalize (if it has it implemented, i.e., is
            # not None).
            if new_array.__array_finalize__:
                new_array.__array_finalize__(original_array)
        return new_array

    def _broadcast_to(array, shape, subok, readonly):
        shape = tuple(shape) if np.iterable(shape) else (shape,)
        array = np.array(array, copy=False, subok=subok)
        if not shape and array.shape:
            raise ValueError('cannot broadcast a non-scalar to a scalar array')
        if any(size < 0 for size in shape):
            raise ValueError('all elements of broadcast shape must be non-'
                             'negative')
        broadcast = np.nditer(
            (array,), flags=['multi_index', 'refs_ok', 'zerosize_ok'],
            op_flags=['readonly'], itershape=shape, order='C').itviews[0]
        result = _maybe_view_as_subclass(array, broadcast)
        if not readonly and array.flags.writeable:
            result.flags.writeable = True
        return result

    def broadcast_to(array, shape, subok=False):
        return _broadcast_to(array, shape, subok=subok, readonly=True)

                        - PyPI metadata (including version constraints): None
                        - Crash traceback: Traceback (most recent call last):
  File "example_classification.py", line 4, in <module>
    from sklearn.datasets import load_digits
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/sklearn/__init__.py", line 57, in <module>
    from .base import clone
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/sklearn/base.py", line 12, in <module>
    from .utils.fixes import signature
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/sklearn/utils/__init__.py", line 11, in <module>
    from .validation import (as_float_array,
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/sklearn/utils/validation.py", line 18, in <module>
    from ..utils.fixes import signature
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/sklearn/utils/fixes.py", line 403, in <module>
    from scipy.stats import rankdata
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/scipy/stats/__init__.py", line 344, in <module>
    from .stats import *
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/scipy/stats/stats.py", line 176, in <module>
    from . import distributions
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/scipy/stats/distributions.py", line 13, in <module>
    from . import _continuous_distns
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/scipy/stats/_continuous_distns.py", line 17, in <module>
    from scipy._lib._numpy_compat import broadcast_to
  File "/home/lei/anaconda3/envs/py36-1/lib/python3.6/site-packages/scipy/_lib/_numpy_compat.py", line 10, in <module>
    from numpy.testing.nosetester import import_nose
ModuleNotFoundError: No module named 'numpy.testing.nosetester'


                        **Analysis Protocol**
                        1. Traceback Pattern Matching：
                        a. Identify error type (ImportError/AttributeError/TypeError)
                        b. Map to possible API changes in numpy v1.18.2 or its dependencies
                        2. Compatibility Matrix Check：
                        a. Verify library-to-library API compatibility through version ranges
                        b. Confirm project-to-library interface compatibility
                        3. Breakpoint Isolation：
                        b. Determine if conflict originates from：
                            • Direct API changes in numpy
                            • Transitive dependency API shifts

                        **Resolution Rules**
                        - PRIMARY CONSTRAINT: Maintain numpy==1.18.2
                        - SECONDARY ADJUSTMENTS: 
                        • Modify dependency versions only when API contracts allow
                        • Prefer backward-compatible minor version changes

                        **Output Mandates**
                        STRICT FORMAT:
                        lib1==x.y.z  
                        lib2==a.b.c
                        ...
                        PROHIBITED:
                        • Any non-version text.
                        • Library additions/removals
                        • Version placeholders
                        MANDATORY:
                        • Preserve original library names and count
                        • Pin EXACT versions
                        • Zero explanations/comments
                        